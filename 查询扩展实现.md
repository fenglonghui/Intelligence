#### 查询扩展实现

     关于RAG检索优化, 查询改写技术的实现, 使用python技术

#### 一、核心思路回顾（来自最新资料汇总）
        同义扩展：对原 query 做同义词/领域词扩充，提高召回率。
        伪文档嵌入（HyDE）：让 LLM 先写“假设回答”，再用它的向量去检索真实段落。
        问题分解：把多跳/对比型问题拆成若干子问题，分别检索后融合。
        对话历史融合：把历史轮次信息拼到当前 query，消解指代。
        意图识别+模板：先判断 query 意图（定义/操作/对比…），再套改写模板。
    
#### 二、依赖安装
        pip install openai sentence-transformers pandas jieba

        任何支持 /v1/embeddings 接口的 LLM 都可无缝替换 OpenAI 层）

#### 三、完整代码（Python 3.8+）

        ```
            # rag_query_rewriter.py

            
            import re, json, itertools, os
            import openai, jieba, pandas as pd
            from typing import List, Dict
            from sentence_transformers import SentenceTransformer
            
            openai.api_key = os.getenv("OPENAI_API_KEY")
            EMBED_MODEL = SentenceTransformer("sentence-transformers/paraphrase-multilingual-MiniLM-L12-v2")
            
            # ---------- 工具 ----------
            def llm(prompt: str, stop=None) -> str:
                """统一 LLM 调用，可替换成任意本地模型"""
                rsp = openai.ChatCompletion.create(
                    model="gpt-3.5-turbo",
                    messages=[{"role": "user", "content": prompt}],
                    stop=stop,
                    temperature=0.3,
                )
                return rsp.choices[0].message.content.strip()
            
            # ---------- 1. 同义扩展 ----------
            def synonym_expand(query: str, topk: int = 3) -> List[str]:
                prompt = f"""请针对查询“{query}”生成{topk}个语义相同但用词不同的新版本，每行一条，无需编号。"""
                lines = llm(prompt).splitlines()
                return [q.strip() for q in lines if q.strip()]
            
            # ---------- 2. HyDE ----------
            def hyde_queries(query: str, num_doc: int = 3) -> List[str]:
                # 让 LLM 先写一段“假设回答”
                hypo = llm(f"请用中文写一段能帮助回答“{query}”的假设性文档，50~80字。")
                # 再让模型根据该假设回答生成 3 个检索 query
                prompt = f"""以下是一段假设性文档：
            { hypo }
            
            请根据该文档生成{num_doc}个可用于向量检索的短 query，每行一条。"""
                lines = llm(prompt).splitlines()
                return [q.strip("-• ") for q in lines if q.strip()]
            
            # ---------- 3. 问题分解 ----------
            def decompose(query: str) -> List[str]:
                prompt = f"""如果“{query}”属于多跳或对比类问题，请把它拆成若干子问题，每行一条；
            否则直接返回原句。"""
                lines = llm(prompt).splitlines()
                return [q.strip("-• ") for q in lines if q.strip()] or [query]
            
            # ---------- 4. 对话历史融合 ----------
            def merge_history(query: str, history: List[str], max_tokens: int = 200) -> str:
                if not history:
                    return query
                hist_text = "；".join(history[-3:])  # 取最近 3 轮
                prompt = f"""历史对话：{hist_text}  
            当前问题：{query}  
            请把指代信息补齐，输出一句完整独立的新问题。"""
                return llm(prompt)
            
            # ---------- 5. 意图识别+模板 ----------
            INTENT_TEMPLATES = {
                "定义": "的概念是什么？有哪些关键点？",
                "操作": "的步骤/方法/示例是什么？",
                "对比": "A 和 B 的异同点/优缺点是什么？",
                "故障": "出现该问题的原因及解决办法？",
            }
            
            def intent_rewrite(query: str) -> str:
                prompt = f"""判断以下 query 的意图类别（定义/操作/对比/故障/其他），只需输出类别名：
            {query}"""
                intent = llm(prompt, stop=["\n"])
                if intent in INTENT_TEMPLATES:
                    return query + INTENT_TEMPLATES[intent]
                return query
            
            # ---------- 统一改写器 ----------
            class RAGQueryRewriter:
                def __init__(self, strategies=None):
                    # 默认策略组合
                    self.strategies = strategies or ["synonym", "hyde", "decompose"]
            
                def rewrite(self, query: str, history: List[str] = None) -> Dict[str, List[str]]:
                    result = {"origin": [query]}
                    if history:
                        query = merge_history(query, history)
                        result["merged"] = [query]
            
                    if "synonym" in self.strategies:
                        result["synonym"] = synonym_expand(query)
                    if "hyde" in self.strategies:
                        result["hyde"] = hyde_queries(query)
                    if "decompose" in self.strategies:
                        result["decompose"] = decompose(query)
                    if "intent" in self.strategies:
                        result["intent"] = [intent_rewrite(query)]
                    return result
            
            # ---------- 快速测试 ----------
            if __name__ == "__main__":
                rw = RAGQueryRewriter(strategies=["synonym", "hyde", "decompose", "intent"])
                his = ["我想学 Python", "列表推导式怎么用"]
                q = "它性能好吗？"
                print(json.dumps(rw.rewrite(q, history=his), ensure_ascii=False, indent=2))

        ```
      
